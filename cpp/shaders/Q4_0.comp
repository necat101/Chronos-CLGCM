#version 450
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Buffers
layout(binding = 0, std430) readonly buffer MatrixA { float A[]; };
layout(binding = 1, std430) readonly buffer QuantizedB { uint B[]; }; // block_q4_0
layout(binding = 2, std430) writeonly buffer MatrixY { float Y[]; };

// Push constants for dimensions
layout(push_constant) uniform PushConstants {
    int K;
    int M;
    int N;
};

// Workgroup shared memory for tiling
shared float tileA[16][16];
shared float tileB[16][16];

// Dequantization function for one element of B
float dequantize_B_element(uint m, uint k) {
    uint block_size_k = 32;
    uint sizeof_block_bytes = 20; // 4 (float) + 16 (uint8_t * 16)
    uint num_blocks_per_row = uint(K) / block_size_k;
    
    uint block_idx = k / block_size_k;
    uint idx_in_block = k % block_size_k;

    uint b_row_offset_uints = m * num_blocks_per_row * sizeof_block_bytes / 4;
    uint block_offset_uints = b_row_offset_uints + block_idx * sizeof_block_bytes / 4;

    // Read scale
    float d = uintBitsToFloat(B[block_offset_uints]);

    // Read packed weights
    uint qs_uint_idx = block_offset_uints + 1 + (idx_in_block / 4);
    uint packed_qs_uint = B[qs_uint_idx];
    
    // Find the specific uint8_t
    int packed_qs_u8 = int((packed_qs_uint >> ((idx_in_block / 2) % 4) * 8) & 0xFF);
    
    int q_val;
    if (idx_in_block % 2 == 0) {
        // Low nibble
        q_val = (packed_qs_u8 & 0x0F) - 8;
    } else {
        // High nibble
        q_val = (packed_qs_u8 >> 4) - 8;
    }

    return float(q_val) * d;
}

void main() {
    uint n_base = gl_WorkGroupID.x * 16; // Base row index for Y (from A)
    uint m_base = gl_WorkGroupID.y * 16; // Base col index for Y (from B)
    
    uint n_local = gl_LocalInvocationID.x;
    uint m_local = gl_LocalInvocationID.y;
    
    uint n_global = n_base + n_local; // Global Y row
    uint m_global = m_base + m_local; // Global Y col

    float sum = 0.0;
    uint k_tiles = (uint(K) + 15) / 16; // Tile size is 16

    for (uint k_tile = 0; k_tile < k_tiles; ++k_tile) {
        // --- 1. Load tiles into shared memory ---
        uint k_global = k_tile * 16 + n_local; // Use n_local for k-dim load

        // Load tileA[m_local][n_local] = A[n_base + m_local, k_tile*16 + n_local]
        if (n_base + m_local < N && k_global < K) {
            tileA[m_local][n_local] = A[(n_base + m_local) * K + k_global];
        } else {
            tileA[m_local][n_local] = 0.0;
        }

        // Load tileB[m_local][n_local] = B[m_base + m_local, k_tile*16 + n_local]
        if (m_base + m_local < M && k_global < K) {
            tileB[m_local][n_local] = dequantize_B_element(m_base + m_local, k_global);
        } else {
            tileB[m_local][n_local] = 0.0;
        }

        barrier(); // Wait for all threads to finish loading

        // --- 2. Compute partial dot product from shared memory ---
        for (uint k = 0; k < 16; ++k) {
            // sum += A[n_global, k_tile*16 + k] * B[m_global, k_tile*16 + k]
            sum += tileA[n_local][k] * tileB[m_local][k];
        }
        barrier(); // Wait for all threads to finish compute
    }

    // --- 3. Write final result ---
    if (n_global < N && m_global < M) {
        Y[n_global * M + m_global] = sum;
    }
}
